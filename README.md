# secp256k1-py
Python FFI bindings for [secp256k1](https://github.com/bitcoin/secp256k1)
(an experimental and optimized C library for EC operations on curve secp256k1).

```
pip install secp256k1
```

[![Build Status](https://travis-ci.org/ludbb/secp256k1-py.svg?branch=master)](https://travis-ci.org/ludbb/secp256k1-py)


## API

### class `secp256k1.PrivateKey(privkey, raw, flags)`

The `PrivateKey` class loads or creates a private key by obtaining 32 bytes from urandom and operates over it.

##### Instantiation parameters

- `privkey=None` - generate a new private key if None, otherwise load a private key.
- `raw=False` - if `True`, it is assumed that `privkey` is in the DER format, otherwise the raw bytes are used as is. This is not used when `privkey` is not specified.
- `flags=secp256k1.ALL_FLAGS` - see Constants.

##### Methods and instance attributes

- `public_key`: an instance of `secp256k1.PublicKey`.
- `private_key`: raw bytes for the private key.

##### `gen_private_keys()` -> bytes
generate a new private key and update the `public_key` and `private_key` for this instance.

##### `serialize(compressed=True)` -> bytes
convert the raw bytes present in `private key` to DER.

##### `deserialize(privkey_ser)` -> bytes
convert from DER bytes to raw bytes and update the `public_key` and `private_key` for this instance.

##### `ecdsa_sign(msg, raw=False, digest=hashlib.sha256)` -> internal object
by default, create an ECDSA-SHA256 signature from the bytes in `msg`. If `raw` is True, then the `digest` function is not applied over `msg`, otherwise the `digest` must produce 256 bits or an `Exception` will be raised.

The returned object is a structure from the C lib. If you want to store it (on a disk or similar), use `ecdsa_serialize` and later on use `ecdsa_deserialize` when loading.

##### `ecdsa_sign_recoverable(msg, raw=False, digest=hashlib.sha256)` -> internal object
create a recoverable ECDSA signature. See `ecdsa_sign` for parameters description.

> NOTE: `ecdsa_sign_recoverable` can only be used if the `secp256k1` C library is compiled with support for it. If there is no support, an Exception will be raised when calling it.


### class `secp256k1.PublicKey(pubkey, raw, flags)`

The `PublicKey` class loads an existing public key and operates over it.

##### Instantiation parameters

- `pubkey=None` - do not load a public key if None, otherwise do.
- `raw=False` - if `False`, it is assumed that `pubkey` has gone through `PublicKey.deserialize` already, otherwise it gets deserialized now.
- `flags=secp256k1.FLAG_VERIFY` - see Constants.

##### Methods and instance attributes

- `public_key`: an internal object representing the public key.

##### `serialize(compressed=True)` -> bytes
convert the `public_key` to bytes. If `compressed` is True, 33 bytes will be produced, otherwise 65 will be.

##### `deserialize(pubkey_ser)` -> internal object
convert the bytes resulting from a previous `serialize` call back to an internal object and update the `public_key` for this instance. The length of `pubkey_ser` determines if it was serialized with `compressed=True` or not.

##### `ecdsa_verify(msg, raw_sig, raw=False, digest=hashlib.sha256)` -> bool
verify an ECDSA signature and return True if the signature is correct, False otherwise. `raw_sig` is expected to be an object returned from `ecdsa_sign` (or if it was serialized using `ecdsa_serialize`, then first run it through `ecdsa_deserialize`). `msg`, `raw`, and `digest` are used as described in `ecdsa_sign`.


### `class ECDSA`

The `ECDSA` class is intended to be used as a mix in. Its methods can be accessed from any `secp256k1.PrivateKey` or `secp256k1.PublicKey` instances.

##### Methods

##### `ecdsa_serialize(raw_sig)` -> bytes
convert the result from `ecdsa_sign` to DER.

##### `ecdsa_deserialie(ser_sig)` -> internal object
convert DER bytes to an internal object.

##### `ecdsa_recover(msg, recover_sig, raw=False, digest=hashlib.sha256)` -> internal object
recover an ECDSA public key from a signature generated by `ecdsa_sign_recoverable`. `recover_sig` is expected to be an object returned from `ecdsa_sign_recoverable` (or if it was serialized using `ecdsa_recoverable_serialize`, then first run it through `ecdsa_recoverable_deserialize`). `msg`, `raw`, and `digest` are used as described in `ecdsa_sign`.

In order to call `ecdsa_recover` from a `PublicKey` instance, it's necessary to create the instance by settings `flags` to `ALL_FLAGS`: `secp256k1.PublicKey(..., flags=secp256k1.ALL_FLAGS)`.

##### `ecdsa_recoverable_serialize(recover_sig)` -> (bytes, int)
convert the result from `ecdsa_sign_recoverable` to a tuple composed of 65 bytesand an integer denominated as recovery id.

##### `ecdsa_recoverable_deserialize(ser_sig, rec_id)`-> internal object
convert the result from `ecdsa_recoverable_serialize` back to an internal object that can be used by `ecdsa_recover`.

##### `ecdsa_recoverable_convert(recover_sig)` -> internal object
convert a recoverable signature to a normal signature, i.e. one that can be used by `ecdsa_serialize` and related methods.

> NOTE: `ecdsa_recover*` can only be used if the `secp256k1` C library is compiled with support for it. If there is no support, an Exception will be raised when calling any of them.


### Constants

##### `secp256k1.FLAG_SIGN`
##### `secp256k1.FLAG_VERIFY`
##### `secp256k1.ALL_FLAGS`

`ALL_FLAGS` combines `FLAG_SIGN` and `FLAG_VERIFY` using bitwise OR.

These flags are used during context creation (undocumented here) and affect which parts of the context are initialized in the C library. In these bindings, some calls are disabled depending on the active flags but this should not be noticeable unless you are manually specifying flags.



## Example

```
from secp256k1 import PrivateKey, PublicKey

privkey = PrivateKey()
privkey_der = privkey.serialize()
assert privkey.deserialize(privkey_der) == privkey.private_key

sig = privkey.ecdsa_sign(b'hello')
verified = privkey.public_key.ecdsa_verify(b'hello', sig)
assert verified

sig_der = privkey.ecdsa_serialize(sig)
sig2 = privkey.ecdsa_deserialize(sig_der)
vrf2 = privkey.public_key.ecdsa_verify(b'hello', sig2)
assert vrf2

pubkey = privkey.public_key
pub = pubkey.serialize()

pubkey2 = PublicKey(pub, raw=True)
assert pubkey2.serialize() == pub
assert pubkey2.ecdsa_verify(b'hello', sig)
```

```
from secp256k1 import PrivateKey

key = '31a84594060e103f5a63eb742bd46cf5f5900d8406e2726dedfc61c7cf43ebad'
msg = '9e5755ec2f328cc8635a55415d0e9a09c2b6f2c9b0343c945fbbfe08247a4cbe'
sig = '30440220132382ca59240c2e14ee7ff61d90fc63276325f4cbe8169fc53ade4a407c2fc802204d86fbe3bde6975dd5a91fdc95ad6544dcdf0dab206f02224ce7e2b151bd82ab'

privkey = PrivateKey(bytes(bytearray.fromhex(key)), raw=True)
sig_check = privkey.ecdsa_sign(bytes(bytearray.fromhex(msg)), raw=True)
sig_ser = privkey.ecdsa_serialize(sig_check)

assert sig_ser == bytes(bytearray.fromhex(sig))
```

```
from secp256k1 import PrivateKey

key = '7ccca75d019dbae79ac4266501578684ee64eeb3c9212105f7a3bdc0ddb0f27e'
pub_compressed = '03e9a06e539d6bf5cf1ca5c41b59121fa3df07a338322405a312c67b6349a707e9'
pub_uncompressed = '04e9a06e539d6bf5cf1ca5c41b59121fa3df07a338322405a312c67b6349a707e94c181c5fe89306493dd5677143a329065606740ee58b873e01642228a09ecf9d'

privkey = PrivateKey(bytes(bytearray.fromhex(key)), raw=True)
pubkey_ser = privkey.public_key.serialize()
pubkey_ser_uncompressed = privkey.public_key.serialize(compressed=False)

assert pubkey_ser == bytes(bytearray.fromhex(pub_compressed))
assert pubkey_ser_uncompressed == bytes(bytearray.fromhex(pub_uncompressed))
```
